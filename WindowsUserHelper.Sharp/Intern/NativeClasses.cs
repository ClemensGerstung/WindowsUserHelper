// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Collections.Concurrent;
using System.Runtime.InteropServices;
using System.Text;

namespace WindowsUserHelper.Sharp.Intern
{
  internal  enum ConnectionState
  {
    Active = 0,
    Connected = 1,
    ConnectQuery = 2,
    Shadow = 3,
    Disconnected = 4,
    Idle = 5,
    Listen = 6,
    Reset = 7,
    Down = 8,
    Init = 9
  }

  internal unsafe class UserInformation : IDisposable
  {
    [StructLayout(LayoutKind.Explicit, Size = 520)]
    public struct __Internal
    {
      [FieldOffset(0)] internal fixed sbyte userName[255];

      [FieldOffset(255)] internal fixed sbyte domainName[255];

      [FieldOffset(512)] internal uint userNameLength;

      [FieldOffset(516)] internal uint domainNameLength;
    }

    public IntPtr __Instance { get; protected set; }

    internal static readonly
      ConcurrentDictionary<IntPtr,
        UserInformation> NativeToManagedMap =
        new ConcurrentDictionary<IntPtr,
          UserInformation>();

    protected bool __ownsNativeInstance;

    internal static UserInformation __CreateInstance(
      IntPtr native, bool skipVTables = false)
    {
      return new UserInformation(native.ToPointer(), skipVTables);
    }

    internal static UserInformation __CreateInstance(
      __Internal native, bool skipVTables = false)
    {
      return new UserInformation(native, skipVTables);
    }

    private static void* __CopyValue(__Internal native)
    {
      var ret = Marshal.AllocHGlobal(sizeof(__Internal));
      *(__Internal*) ret = native;
      return ret.ToPointer();
    }

    private UserInformation(__Internal native,
      bool skipVTables = false)
      : this(__CopyValue(native), skipVTables)
    {
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
    }

    protected UserInformation(void* native, bool skipVTables = false)
    {
      if (native == null)
        return;
      __Instance = new IntPtr(native);
    }

    public UserInformation()
    {
      __Instance = Marshal.AllocHGlobal(sizeof(__Internal));
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
    }

    public UserInformation(UserInformation _0)
    {
      __Instance = Marshal.AllocHGlobal(sizeof(__Internal));
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
      *(__Internal*) __Instance =
        *(__Internal*) _0.__Instance;
    }

    public void Dispose()
    {
      Dispose(true);
    }

    public virtual void Dispose(bool disposing)
    {
      if (__Instance == IntPtr.Zero)
        return;
      UserInformation __dummy;
      NativeToManagedMap.TryRemove(__Instance, out __dummy);
      if (__ownsNativeInstance)
        Marshal.FreeHGlobal(__Instance);
      __Instance = IntPtr.Zero;
    }

    public sbyte[] UserName
    {
      get
      {
        sbyte[] __value = null;
        if (((__Internal*) __Instance)->userName != null)
        {
          __value = new sbyte[255];
          for (var i = 0; i < 255; i++)
            __value[i] =
              ((__Internal*) __Instance)->userName[i];
        }

        return __value;
      }

      set
      {
        if (value != null)
          for (var i = 0; i < 255; i++)
            ((__Internal*) __Instance)->userName[i] =
              value[i];
      }
    }

    public sbyte[] DomainName
    {
      get
      {
        sbyte[] __value = null;
        if (((__Internal*) __Instance)->domainName != null)
        {
          __value = new sbyte[255];
          for (var i = 0; i < 255; i++)
            __value[i] =
              ((__Internal*) __Instance)->domainName[i];
        }

        return __value;
      }

      set
      {
        if (value != null)
          for (var i = 0; i < 255; i++)
            ((__Internal*) __Instance)->domainName[i] =
              value[i];
      }
    }

    public uint UserNameLength
    {
      get => ((__Internal*) __Instance)->userNameLength;

      set => ((__Internal*) __Instance)->userNameLength = value;
    }

    public uint DomainNameLength
    {
      get => ((__Internal*) __Instance)->domainNameLength;

      set => ((__Internal*) __Instance)->domainNameLength = value;
    }
  }

  internal  unsafe class UserImpersonation : IDisposable
  {
    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public struct __Internal
    {
      [FieldOffset(0)] internal IntPtr message;

      [FieldOffset(8)] internal IntPtr caption;

      [FieldOffset(16)] internal IntPtr userName;

      [FieldOffset(24)] internal IntPtr parentWindow;

      [FieldOffset(32)] internal IntPtr bitmap;
    }

    public IntPtr __Instance { get; protected set; }

    internal static readonly
      ConcurrentDictionary<IntPtr,
        UserImpersonation> NativeToManagedMap =
        new ConcurrentDictionary<IntPtr,
          UserImpersonation>();

    protected bool __ownsNativeInstance;

    internal static UserImpersonation __CreateInstance(
      IntPtr native, bool skipVTables = false)
    {
      return new UserImpersonation(native.ToPointer(), skipVTables);
    }

    internal static UserImpersonation __CreateInstance(
      __Internal native, bool skipVTables = false)
    {
      return new UserImpersonation(native, skipVTables);
    }

    private static void* __CopyValue(__Internal native)
    {
      var ret = Marshal.AllocHGlobal(sizeof(__Internal));
      *(__Internal*) ret = native;
      return ret.ToPointer();
    }

    private UserImpersonation(__Internal native,
      bool skipVTables = false)
      : this(__CopyValue(native), skipVTables)
    {
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
    }

    protected UserImpersonation(void* native, bool skipVTables = false)
    {
      if (native == null)
        return;
      __Instance = new IntPtr(native);
    }

    public UserImpersonation()
    {
      __Instance =
        Marshal.AllocHGlobal(sizeof(__Internal));
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
    }

    public UserImpersonation(UserImpersonation _0)
    {
      __Instance =
        Marshal.AllocHGlobal(sizeof(__Internal));
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
      *(__Internal*) __Instance =
        *(__Internal*) _0.__Instance;
    }

    public void Dispose()
    {
      Dispose(true);
    }

    public virtual void Dispose(bool disposing)
    {
      if (__Instance == IntPtr.Zero)
        return;
      UserImpersonation __dummy;
      NativeToManagedMap.TryRemove(__Instance, out __dummy);
      if (__ownsNativeInstance)
        Marshal.FreeHGlobal(__Instance);
      __Instance = IntPtr.Zero;
    }

    public string Message
    {
      get
      {
        if (((__Internal*) __Instance)->message ==
            IntPtr.Zero)
          return default;
        var __retPtr =
          (byte*) ((__Internal*) __Instance)->message;
        var __length = 0;
        while (*__retPtr++ != 0) __length += sizeof(byte);
        return Encoding.UTF8.GetString(
          (byte*) ((__Internal*) __Instance)->message,
          __length);
      }

      set
      {
        var __bytes0 = Encoding.UTF8.GetBytes(value);
        fixed (byte* __bytePtr0 = __bytes0)
        {
          ((__Internal*) __Instance)->message =
            new IntPtr(__bytePtr0);
        }
      }
    }

    public string Caption
    {
      get
      {
        if (((__Internal*) __Instance)->caption ==
            IntPtr.Zero)
          return default;
        var __retPtr =
          (byte*) ((__Internal*) __Instance)->caption;
        var __length = 0;
        while (*__retPtr++ != 0) __length += sizeof(byte);
        return Encoding.UTF8.GetString(
          (byte*) ((__Internal*) __Instance)->caption,
          __length);
      }

      set
      {
        var __bytes0 = Encoding.UTF8.GetBytes(value);
        fixed (byte* __bytePtr0 = __bytes0)
        {
          ((__Internal*) __Instance)->caption =
            new IntPtr(__bytePtr0);
        }
      }
    }

    public string UserName
    {
      get
      {
        if (((__Internal*) __Instance)->userName ==
            IntPtr.Zero)
          return default;
        var __retPtr =
          (byte*) ((__Internal*) __Instance)->userName;
        var __length = 0;
        while (*__retPtr++ != 0) __length += sizeof(byte);
        return Encoding.UTF8.GetString(
          (byte*) ((__Internal*) __Instance)->userName,
          __length);
      }

      set
      {
        var __bytes0 = Encoding.UTF8.GetBytes(value);
        fixed (byte* __bytePtr0 = __bytes0)
        {
          ((__Internal*) __Instance)->userName =
            new IntPtr(__bytePtr0);
        }
      }
    }
  }

  internal  unsafe class Server : IDisposable
  {
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct __Internal
    {
      [FieldOffset(0)] internal IntPtr handle;

      [FieldOffset(8)] internal IntPtr name;
    }

    public IntPtr __Instance { get; protected set; }

    internal static readonly
      ConcurrentDictionary<IntPtr,
        Server> NativeToManagedMap =
        new ConcurrentDictionary<IntPtr,
          Server>();

    protected bool __ownsNativeInstance;

    internal static Server __CreateInstance(IntPtr native,
      bool skipVTables = false)
    {
      return new Server(native.ToPointer(), skipVTables);
    }

    internal static Server __CreateInstance(
      __Internal native, bool skipVTables = false)
    {
      return new Server(native, skipVTables);
    }

    private static void* __CopyValue(__Internal native)
    {
      var ret = Marshal.AllocHGlobal(sizeof(__Internal));
      *(__Internal*) ret = native;
      return ret.ToPointer();
    }

    private Server(__Internal native, bool skipVTables = false)
      : this(__CopyValue(native), skipVTables)
    {
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
    }

    protected Server(void* native, bool skipVTables = false)
    {
      if (native == null)
        return;
      __Instance = new IntPtr(native);
    }

    public Server()
    {
      __Instance = Marshal.AllocHGlobal(sizeof(__Internal));
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
    }

    public Server(Server _0)
    {
      __Instance = Marshal.AllocHGlobal(sizeof(__Internal));
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
      *(__Internal*) __Instance =
        *(__Internal*) _0.__Instance;
    }

    public void Dispose()
    {
      Dispose(true);
    }

    public virtual void Dispose(bool disposing)
    {
      if (__Instance == IntPtr.Zero)
        return;
      Server __dummy;
      NativeToManagedMap.TryRemove(__Instance, out __dummy);
      if (__ownsNativeInstance)
        Marshal.FreeHGlobal(__Instance);
      __Instance = IntPtr.Zero;
    }

    public IntPtr Handle
    {
      get => ((__Internal*) __Instance)->handle;

      set =>
        ((__Internal*) __Instance)->handle =
        value;
    }

    public string Name
    {
      get
      {
        if (((__Internal*) __Instance)->name ==
            IntPtr.Zero)
          return default;
        var __retPtr = (byte*) ((__Internal*) __Instance)->name;
        var __length = 0;
        while (*__retPtr++ != 0) __length += sizeof(byte);
        return Encoding.UTF8.GetString(
          (byte*) ((__Internal*) __Instance)->name, __length);
      }

      set
      {
        var __bytes0 = Encoding.UTF8.GetBytes(value);
        fixed (byte* __bytePtr0 = __bytes0)
        {
          ((__Internal*) __Instance)->name =
            new IntPtr(__bytePtr0);
        }
      }
    }
  }

  internal  unsafe class Session : IDisposable
  {
    [StructLayout(LayoutKind.Explicit, Size = 1028)]
    public struct __Internal
    {
      [FieldOffset(0)] internal ConnectionState state;

      [FieldOffset(4)] internal uint sessionId;

      [FieldOffset(8)] internal fixed sbyte sessionName[255];

      [FieldOffset(263)] internal fixed sbyte hostName[255];

      [FieldOffset(518)] internal fixed sbyte userName[255];

      [FieldOffset(773)] internal fixed sbyte domainName[255];
    }

    public IntPtr __Instance { get; protected set; }

    internal static readonly
      ConcurrentDictionary<IntPtr,
        Session> NativeToManagedMap =
        new ConcurrentDictionary<IntPtr,
          Session>();

    protected bool __ownsNativeInstance;

    internal static Session __CreateInstance(IntPtr native,
      bool skipVTables = false)
    {
      return new Session(native.ToPointer(), skipVTables);
    }

    internal static Session __CreateInstance(
      __Internal native, bool skipVTables = false)
    {
      return new Session(native, skipVTables);
    }

    private static void* __CopyValue(__Internal native)
    {
      var ret = Marshal.AllocHGlobal(sizeof(__Internal));
      *(__Internal*) ret = native;
      return ret.ToPointer();
    }

    private Session(__Internal native, bool skipVTables = false)
      : this(__CopyValue(native), skipVTables)
    {
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
    }

    protected Session(void* native, bool skipVTables = false)
    {
      if (native == null)
        return;
      __Instance = new IntPtr(native);
    }

    public Session()
    {
      __Instance = Marshal.AllocHGlobal(sizeof(__Internal));
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
    }

    public Session(Session _0)
    {
      __Instance = Marshal.AllocHGlobal(sizeof(__Internal));
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
      *(__Internal*) __Instance =
        *(__Internal*) _0.__Instance;
    }

    public void Dispose()
    {
      Dispose(true);
    }

    public virtual void Dispose(bool disposing)
    {
      if (__Instance == IntPtr.Zero)
        return;
      Session __dummy;
      NativeToManagedMap.TryRemove(__Instance, out __dummy);
      if (__ownsNativeInstance)
        Marshal.FreeHGlobal(__Instance);
      __Instance = IntPtr.Zero;
    }

    public ConnectionState State
    {
      get => ((__Internal*) __Instance)->state;

      set => ((__Internal*) __Instance)->state = value;
    }

    public uint SessionId
    {
      get => ((__Internal*) __Instance)->sessionId;

      set => ((__Internal*) __Instance)->sessionId = value;
    }

    public sbyte[] SessionName
    {
      get
      {
        sbyte[] __value = null;
        if (((__Internal*) __Instance)->sessionName != null)
        {
          __value = new sbyte[255];
          for (var i = 0; i < 255; i++)
            __value[i] = ((__Internal*) __Instance)->sessionName[i];
        }

        return __value;
      }

      set
      {
        if (value != null)
          for (var i = 0; i < 255; i++)
            ((__Internal*) __Instance)->sessionName[i] = value[i];
      }
    }

    public sbyte[] HostName
    {
      get
      {
        sbyte[] __value = null;
        if (((__Internal*) __Instance)->hostName != null)
        {
          __value = new sbyte[255];
          for (var i = 0; i < 255; i++)
            __value[i] = ((__Internal*) __Instance)->hostName[i];
        }

        return __value;
      }

      set
      {
        if (value != null)
          for (var i = 0; i < 255; i++)
            ((__Internal*) __Instance)->hostName[i] = value[i];
      }
    }

    public sbyte[] UserName
    {
      get
      {
        sbyte[] __value = null;
        if (((__Internal*) __Instance)->userName != null)
        {
          __value = new sbyte[255];
          for (var i = 0; i < 255; i++)
            __value[i] = ((__Internal*) __Instance)->userName[i];
        }

        return __value;
      }

      set
      {
        if (value != null)
          for (var i = 0; i < 255; i++)
            ((__Internal*) __Instance)->userName[i] = value[i];
      }
    }

    public sbyte[] DomainName
    {
      get
      {
        sbyte[] __value = null;
        if (((__Internal*) __Instance)->domainName != null)
        {
          __value = new sbyte[255];
          for (var i = 0; i < 255; i++)
            __value[i] = ((__Internal*) __Instance)->domainName[i];
        }

        return __value;
      }

      set
      {
        if (value != null)
          for (var i = 0; i < 255; i++)
            ((__Internal*) __Instance)->domainName[i] = value[i];
      }
    }
  }

  internal  unsafe class Process : IDisposable
  {
    [StructLayout(LayoutKind.Explicit, Size = 276)]
    public struct __Internal
    {
      [FieldOffset(0)] internal uint sessionId;

      [FieldOffset(4)] internal uint processId;

      [FieldOffset(8)] internal fixed sbyte processName[255];

      [FieldOffset(264)] internal uint numberOfThreads;

      [FieldOffset(268)] internal uint pagefileUsage;

      [FieldOffset(272)] internal uint workingSetSize;
    }

    public IntPtr __Instance { get; protected set; }

    internal static readonly
      ConcurrentDictionary<IntPtr,
        Process> NativeToManagedMap =
        new ConcurrentDictionary<IntPtr,
          Process>();

    protected bool __ownsNativeInstance;

    internal static Process __CreateInstance(IntPtr native,
      bool skipVTables = false)
    {
      return new Process(native.ToPointer(), skipVTables);
    }

    internal static Process __CreateInstance(
      __Internal native, bool skipVTables = false)
    {
      return new Process(native, skipVTables);
    }

    private static void* __CopyValue(__Internal native)
    {
      var ret = Marshal.AllocHGlobal(sizeof(__Internal));
      *(__Internal*) ret = native;
      return ret.ToPointer();
    }

    private Process(__Internal native, bool skipVTables = false)
      : this(__CopyValue(native), skipVTables)
    {
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
    }

    protected Process(void* native, bool skipVTables = false)
    {
      if (native == null)
        return;
      __Instance = new IntPtr(native);
    }

    public Process()
    {
      __Instance = Marshal.AllocHGlobal(sizeof(__Internal));
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
    }

    public Process(Process _0)
    {
      __Instance = Marshal.AllocHGlobal(sizeof(__Internal));
      __ownsNativeInstance = true;
      NativeToManagedMap[__Instance] = this;
      *(__Internal*) __Instance =
        *(__Internal*) _0.__Instance;
    }

    public void Dispose()
    {
      Dispose(true);
    }

    public virtual void Dispose(bool disposing)
    {
      if (__Instance == IntPtr.Zero)
        return;
      Process __dummy;
      NativeToManagedMap.TryRemove(__Instance, out __dummy);
      if (__ownsNativeInstance)
        Marshal.FreeHGlobal(__Instance);
      __Instance = IntPtr.Zero;
    }

    public uint SessionId
    {
      get => ((__Internal*) __Instance)->sessionId;

      set => ((__Internal*) __Instance)->sessionId = value;
    }

    public uint ProcessId
    {
      get => ((__Internal*) __Instance)->processId;

      set => ((__Internal*) __Instance)->processId = value;
    }

    public sbyte[] ProcessName
    {
      get
      {
        sbyte[] __value = null;
        if (((__Internal*) __Instance)->processName != null)
        {
          __value = new sbyte[255];
          for (var i = 0; i < 255; i++)
            __value[i] = ((__Internal*) __Instance)->processName[i];
        }

        return __value;
      }

      set
      {
        if (value != null)
          for (var i = 0; i < 255; i++)
            ((__Internal*) __Instance)->processName[i] = value[i];
      }
    }

    public uint NumberOfThreads
    {
      get => ((__Internal*) __Instance)->numberOfThreads;

      set => ((__Internal*) __Instance)->numberOfThreads = value;
    }

    public uint PagefileUsage
    {
      get => ((__Internal*) __Instance)->pagefileUsage;

      set => ((__Internal*) __Instance)->pagefileUsage = value;
    }

    public uint WorkingSetSize
    {
      get => ((__Internal*) __Instance)->workingSetSize;

      set => ((__Internal*) __Instance)->workingSetSize = value;
    }
  }
}